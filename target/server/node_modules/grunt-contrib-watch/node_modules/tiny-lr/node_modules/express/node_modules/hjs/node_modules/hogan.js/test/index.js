/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

var is = strictEqual;

test("Scan Text No Tags", function() {
  var text = "<h2>hi</h2>";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0]+'', text, "text is equal to first token");
});

test("Scan One Tag", function() {
  var text = "{{hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
});

test("Scan Multiple Tags", function() {
  var text = "asdf{{hmm}}asdf2{{hmm2}}asdf3";
  var tokens = Hogan.scan(text);
  is(tokens.length, 5, "3 text tokens, 2 tag tokens.");
  is(tokens[0]+'', "asdf", "first token is text");
  is(tokens[1].n, "hmm", "second token is tag");
  is(tokens[1].tag, "_v", "second token is a variable");
  is(tokens[2]+'', "asdf2", "third token is text");
  is(tokens[3].n, "hmm2", "fourth token is tag");
  is(tokens[3].tag, "_v", "fourth token is a variable");
  is(tokens[4]+'', "asdf3", "Fifth token is text");
});

test("Scan Section Open", function() {
  var text = "{{#hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, "#", "First token is a section.");
});

test("Scan Section Close", function() {
  var text = "{{/hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, "/", "First token is a section.");
});

test("Scan Section", function() {
  var text = "{{#hmm}}{{/hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 2, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, "#", "First token is a section.");
  is(tokens[1].n, "hmm", "Second token content is variable name.");
  is(tokens[1].tag, "/", "Second token is a section.");
});

test("Scan Section In Content", function() {
  var text = "abc{{#hmm}}def{{/hmm}}ghi";
  var tokens = Hogan.scan(text);
  is(tokens.length, 5, "3 text tokens, 2 tag tokens.");
  is(tokens[0]+'', "abc", "first token is text");
  is(tokens[1].n, "hmm", "second token is tag");
  is(tokens[1].tag, "#", "second token is a variable");
  is(tokens[2]+'', "def", "third token is text");
  is(tokens[3].n, "hmm", "fourth token is tag");
  is(tokens[3].tag, "/", "fourth token is a variable");
  is(tokens[4]+'', "ghi", "Fifth token is text");
});

test("Scan Negative Section", function() {
  var text = "{{^hmm}}{{/hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 2, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, "^", "First token is a negative section.");
  is(tokens[1].n, "hmm", "First token content is variable name.");
  is(tokens[1].tag, "/", "Second token is a section.");
});

test("Scan Partial", function() {
  var text = "{{>hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, ">", "First token is a partial.");
});

test("Scan Backward Partial", function() {
  var text = "{{<hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, "<", "First token is a backward partial.");
});

test("Scan Ampersand No Escape Tag", function() {
  var text = "{{&hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, "&", "First token is an ampersand no-escape.");
});

test("Scan Triple Stache", function() {
  var text = "{{{hmm}}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 1, "One token");
  is(tokens[0].n, "hmm", "First token content is variable name.");
  is(tokens[0].tag, "{", "First token is a triple-stache.");
});

test("Scan Section With Triple Stache Inside", function() {
  var text = "a{{#yo}}b{{{hmm}}}c{{/yo}}d";
  var tokens = Hogan.scan(text);
  is(tokens.length, 7, "One token");
  is(tokens[0]+'', "a", "First token content is correct text.");
  is(tokens[1].n, "yo", "Second token content is correct text.");
  is(tokens[1].tag, "#", "Second token is a section.");
  is(tokens[2]+'', "b", "Third token content is correct text.");
  is(tokens[3].n, "hmm", "Fourth token content is correct text.");
  is(tokens[3].tag, "{", "Fourth token is a triple stache.");
  is(tokens[4]+'', "c", "Fifth token content is correct text.");
  is(tokens[5].n, "yo", "Sixth token content is correct text.");
  is(tokens[5].tag, "/", "Sixth token is a close.");
  is(tokens[6]+'', "d", "Seventh token content is correct text.");
});

test("Scan Set Delimiter", function() {
  var text = "a{{=<% %>=}}b";
  var tokens = Hogan.scan(text);
  is(tokens.length, 2, "change delimiter doesn't appear as token.");
  is(tokens[0]+'', "a", "text before change delimiter is processed.");
  is(tokens[1]+'', "b", "text after change delimiter is processed.");
});

test("Scan Reset Delimiter", function() {
  var text = "a{{=<% %>=}}b<%hmm%>c<%={{ }}=%>d{{hmm}}";
  var tokens = Hogan.scan(text);
  is(tokens.length, 6, "8 tokens, delimiter changes don't count.");
  is(tokens[0]+'', "a", "first token is correct.");
  is(tokens[1]+'', "b", "third token is correct.");
  is(tokens[2].tag, "_v", "third token is correct tag.");
  is(tokens[2].n, "hmm", "third token is correct name.");
  is(tokens[3]+'', "c", "fifth token is correct.");
  is(tokens[4]+'', "d", "seventh token is correct.");
  is(tokens[5].tag, "_v", "eighth token is correct tag.");
  is(tokens[5].n, "hmm", "eighth token is correct name.");
});

test("Single Char Delimiter", function() {
  var text = '({{foo}} {{=[ ]=}}[text])';
  var tokens = Hogan.scan(text);

  var t = Hogan.compile(text);
  s = t.render({foo: "bar", text: 'It worked!'});
  is(s, '(bar It worked!)', "Hogan substitution worked after custom delimiters.");
});

test("Set Delimiter With Whitespace", function() {
  var text = "{{= | | =}}|foo|";
  var t = Hogan.compile(text);
  s = t.render({foo: "bar"});
  is(s, 'bar', "custom delimiters with whitespace works.")
});

test("Parse Basic", function() {
  var text = "test";
  var tree = Hogan.parse(Hogan.scan(text));
  is(tree.length, 1, "one parse node");
  is(tree[0]+'', "test", "text is correct");
});

test("Parse Variables", function() {
  var text = "test{{foo}}test!{{bar}}test!!{{baz}}test!!!";
  var tree = Hogan.parse(Hogan.scan(text));
  is(tree.length, 7, "one parse node");
  is(tree[0]+'', "test", "first text is correct");
  is(tree[2]+'', "test!", "second text is correct")
  is(tree[4]+'', "test!!", "third text is correct")
  is(tree[6]+'', "test!!!", "last text is correct")
  is(tree[1].n, "foo", "first var is correct");
  is(tree[3].n, "bar", "second var is correct");
  is(tree[5].n, "baz", "third var is correct");
});

test("Parse Section", function() {
  var text = "a{{#foo}}b{{/foo}}c";
  var tree = Hogan.parse(Hogan.scan(text));
  is(tree.length, 3, "three nodes at base");
  is(tree[0]+'', "a", "correct text in first node");
  is(tree[1].hasOwnProperty('nodes'), true, "second node is a section");
  is(tree[1].tag, '#', "second node is a section");
  is(tree[1].n, "foo", "correct name for section");
  is(tree[1].nodes[0]+'', "b", "correct text in section");
  is(tree[2]+'', "c", "correct text in last node");
});

test("Parse Indexes", function() {
  var text = "abc{{#foo}}asdf{{bar}}asdf{{/foo}}def";
  var tree = Hogan.parse(Hogan.scan(text));
  is(text.substring(tree[1].i, tree[1].end), "asdf{{bar}}asdf", "section text indexes are correct");
});

test("Parse Negative Section", function() {
  var text = "a{{^foo}}b{{/foo}}c";
  var tree = Hogan.parse(Hogan.scan(text));

  is(tree.length, 3, "three nodes at base");
  is(tree[0]+'', "a", "correct text in first node");
  is(tree[1].hasOwnProperty('nodes'), true, "second node is a section");
  is(tree[1].tag, '^', "second node is a negative section");
  is(tree[1].n, "foo", "correct name for section");
  is(tree[1].nodes[0]+'', "b", "correct text in section");
  is(tree[2]+'', "c", "correct text in last node");
});

test("Parse Nested Sections", function() {
  var text = "{{#bar}}{{#foo}}c{{/foo}}{{/bar}}"
  var tree = Hogan.parse(Hogan.scan(text));

  is(tree.length, 1, "one node at base");
  is(tree[0].tag, "#", "open section is first node");
  is(tree[0].n, "bar", "first section name is 'bar'");
  is(tree[0].nodes.length, 1, "first section contains one node.");
  is(tree[0].nodes[0].n, "foo", "correct name for nested section");
  is(tree[0].nodes[0].nodes[0]+'', "c", "correct text in nested section");
});

test("Missing Closing Tag", function() {
  var text = "a{{#foo}}bc";
  raises(function() {
    var tree = Hogan.parse(Hogan.scan(text));
  }, "missing closing tag: foo", "Error is generated");
});

test("Bad Nesting", function() {
  var text = "a{{#foo}}{{#bar}}b{{/foo}}{{/bar}}c";
  raises(function() {
    var tree = Hogan.parse(Hogan.scan(text));
  }, "Nesting error: bar vs. foo", "Error is generated");
});

test("Basic Output", function() {
  var text = "test";
  var t = Hogan.compile(text);
  is(t.render(), text, "template renders one text node");
});

test("Basic Output As String", function() {
  return;
  var text = "test";
  var textFunc = Hogan.compile(text, true);
  is(textFunc, "function(context, partials){this.buffer.push('test');};", "template renders correct text function.");
});

test("One Variable", function() {
  var text = "test {{foo}} test";
  var t = Hogan.compile(text);
  var s = t.render({foo:'bar'});
  is(s, "test bar test", "basic variable substitution works.");
});

test("One Variable As String", function() {
  return;
  var text = "test {{foo}} test";
  var funcText = Hogan.compile(text, true);
  is(funcText, "function(context, partials){this.buffer.push('test ');\nthis.buffer.push(this.find('foo', context));\nthis.buffer.push(' test');};",
     "Function text is correct with variable substitution.");
});

test("Render With Whitespace", function() {
  var text = "{{ string }}";
  var t = Hogan.compile(text);
  is(t.render({string: "---" }), "---", "tags with whitespace render correctly.");
});

test("Render With Whitespace Around Triple Stache", function() {
  var text = "  {{{string}}}\n";
  var t = Hogan.compile(text);
  is(t.render({string: "---" }), "  ---\n", "triple stache surrounded by whitespace render correctly.");
});

test("Render With Whitespace Around Ampersand", function() {
  var text = "  {{& string }}\n";
  var t = Hogan.compile(text);
  is(t.render({string: "---" }), "  ---\n", "ampersand surrounded by whitespace render correctly.");
});

test("Multiple Variables", function() {
  var text = "test {{foo}} test {{bar}} test {{baz}} test {{foo}} test";
  var t = Hogan.compile(text);
  var s = t.render({foo:'42', bar: '43', baz: '44'});
  is(s, "test 42 test 43 test 44 test 42 test", "all variables render correctly.");
});

test("Number Values", function() {
  var text = "integer: {{foo}} float: {{bar}} negative: {{baz}}";
  var t = Hogan.compile(text);
  var s = t.render({foo: 42, bar: 42.42, baz: -42});
  is(s, "integer: 42 float: 42.42 negative: -42", "numbers render correctly");
});

test("Object Render", function() {
  var text = "object: {{foo}}";
  var t = Hogan.compile(text);
  var s = t.render({foo: {}});
  is(s, "object: [object Object]", "objects render default toString.");
});

test("Object To String Render", function() {
  var text = "object: {{foo}}";
  var t = Hogan.compile(text);
  var s = t.render({foo: {toString: function(){ return "yo!"}}});
  is(s, "object: yo!", "objects render supplied toString.");
});

test("Array Render", function() {
  var text = "array: {{foo}}";
  var t = Hogan.compile(text);
  var s = t.render({foo: ["a","b","c"]});
  is(s, "array: a,b,c", "arrays render default toString.");
});

test("Escaping", function() {
  var text = "{{foo}}";
  var t = Hogan.compile(text);
  var s = t.render();
  var s = t.render({foo: "< > <div> \' \" &"});
  is(s, "&lt; &gt; &lt;div&gt; &#39; &quot; &amp;", "input correctly escaped.");

  var ec ={ "'": "&#39;", '"': "&quot;", "<": "&lt;", "